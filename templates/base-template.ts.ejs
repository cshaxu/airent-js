<%
/** string utils */

function toKababCase(string) {
  return string
    .replace(/_/g, '-')
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .toLowerCase();
}

function toTitleCase(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

/** type utils */
function isEntityType(type) { return !!type.entity; }
function isDefinableType(type) { return !!type.define?.length; }
function isEnumerableType(type) { return !!type.enum?.length; }
function isInternalType(type) { return isDefinableType(type) || isEnumerableType(type); }
function isImportableType(type) { return !!type.import?.length; }

/** field utils */

function isAssociationField(field) { return field.strategy === 'association'; }
function isComputedSyncField(field) { return field.strategy === 'computed_sync'; }
function isComputedAsyncField(field) { return field.strategy === 'computed_async'; }
function isPrimitiveField(field) { return field.strategy === 'primitive'; }
function isExternalField(field) { return !field.internal; }
function isSyncField(field) { return isPrimitiveField(field) || isComputedSyncField(field); }
function isArrayField(field) { return field.type.endsWith('[]'); }
function isNullableField(field) { return field.type.endsWith(' | null'); }

function getFieldGetterName(field) {
  if (isPrimitiveField(field)) {
    return `${field.name}`;
  }
  return `get${toTitleCase(field.name)}()`;
}

function getFieldGetter(prefix, field) {
  const getterName = `${prefix}${getFieldGetterName(field)}`;
  if (isSyncField(field)) {
    return getterName;
  } else {
    return `await ${getterName}`;
  }
}

function queryField(fieldName) {
  return fields.find((field) => field.name === fieldName) ?? {
    name: fieldName,
    type: 'any',
    strategy: 'primitive',
  };
}

function getSourceFields(field) {
  return (field.sourceFields ?? [])
    .map(queryField)
    .filter(Boolean)
    .filter(isSyncField);
}

function getSourceKey(field) {
  const getters = getSourceFields(field)
    .map((sf) => getFieldGetter('one.', sf))
  if (getters.length === 1) {
    return getters[0];
  }
  return '`' + getters.map((getter) => `\${${getter}}`).join('*') + '`';
}

function getTargetKey(field) {
  const getters = (field.targetFields ?? [])
    .map((fieldName) => `one.${fieldName}`);
  if (getters.length === 1) {
    return getters[0];
  }
  return '`' + getters.map((getter) => `\${${getter}}`).join('*') + '`';
}

function hasSourceKey(field) {
  return getSourceFields(field).length;
}

function hasTargetKey(field) {
  return field.targetFields?.length;
}

function hasAssociationKeys(field) {
  return hasSourceKey(field) && hasTargetKey(field);
}

function getFieldParamsName(field) {
  const className = getEntityStrings().entityClass;
  const fieldName = field.name;
  return `${className}.${fieldName}`;
}

/** class utils */

function getModuleSuffix() { return isModule ? '.js' : ''; }

function getTypeStrings(type) {
  if (isEntityType(type)) {
    const prefix = `${toKababCase(type.name)}`;
    const suffix = getModuleSuffix();
    return {
      entityClass: `${type.name}Entity`,
      entityPackage: `${prefix}${suffix}`,
      fieldRequestClass: `${type.name}FieldRequest`,
      responseClass: `${type.name}Response`,
      typePackage: `${prefix}-type${suffix}`,
    };
  } else if (isImportableType(type)) {
    return { externalClass: type.name, externalPackage: type.import };
  } else if (isDefinableType(type)) {
    return { typeName: type.name, typeDefinition: type.define };
  } else if (isEnumerableType(type)) {
    return { typeName: type.name, typeDefinition: type.enum };
  } else {
    throw new Error(`invalid type ${type.name}`);
  }
}

function getEntityStrings() {
  const prefix = toKababCase(entityName);
  const suffix = getModuleSuffix();
  return {
    entName: entityName,
    baseClass: `${entityName}EntityBase`,
    entityClass: `${entityName}Entity`,
    fieldRequestClass: `${entityName}FieldRequest`,
    responseClass: `${entityName}Response`,
    basePackage: `${prefix}-base${suffix}`,
    entityPackage: `${prefix}${suffix}`,
    typePackage: `${prefix}-type${suffix}`,
  };
}

function getAssociationStrings(field) {
  const entName = toTitleCase(field.type.split("|")[0].split("[]")[0].trim());

  const prefix = toKababCase(entName);
  const suffix = getModuleSuffix();

  const entityClass = `${entName}Entity`;
  const responseClass = `${entName}Response`;

  return {
    entName,
    entityClass,
    fieldRequestClass: `${entName}FieldRequest`,
    responseClass,
    entityPackage: `${prefix}${suffix}`,
    typePackage: `${prefix}-type${suffix}`,
    entityFieldType: field.type.replace(entName, entityClass),
    responseFieldType: field.type.replace(entName, responseClass),
  };
}

/** base template specific utils */

function getFieldPresenter(field) {
  const condition = `fieldRequest?.${field.name}`;
  let getter = getFieldGetter('this.', field);

  if (isAssociationField(field)) {
    if (isArrayField(field)) {
      getter += `.then((a) => Promise.all(a.map((one) => one.present(${condition}))))`;
    } else if (isNullableField(field)) {
      getter += `.then((one) => one ? one.present(${condition}) : Promise.resolve(null))`;
    } else {
      getter += `.then((one) => one.present(${condition}))`;
    }
  }

  return `${condition} ? ${getter} : undefined`;
}

/** base template follows */
-%>
import { AsyncLock, BaseEntity, LoadParams, buildArrayMap, buildObjectMap } from '<%= airentPackage %>';
<% if (!internal || fields.some(isInternalType)) { -%>

/** generated */
import {
  <%= getEntityStrings().fieldRequestClass %>,
  <%= getEntityStrings().responseClass %>,
<% types.filter(isInternalType).forEach((type) => { -%>
  <%= getTypeStrings(type).typeName %>,
<% }); -%>
} from './<%= getEntityStrings().typePackage %>';
<% } -%>
<% if (types.some(isEntityType)) { -%>

/** associations */
<% types.filter(isEntityType).forEach((type) => { -%>
import { <%= getTypeStrings(type).entityClass %> } from '../<%= getTypeStrings(type).entityPackage %>';
<% }); -%>
<% } -%>
<% if (types.some(isImportableType)) { -%>

/** external types */
<% types.filter(isImportableType).forEach((type) => { -%>
import { <%= getTypeStrings(type).externalClass %> } from '<%= getTypeStrings(type).externalPackage %>';
<% }); -%>
<% } -%>

export class <%= getEntityStrings().baseClass %> extends BaseEntity<
  <%= modelName %><%= internal ? '' : `, ${getEntityStrings().fieldRequestClass}, ${getEntityStrings().responseClass}` %>
> {
<% fields.filter(isPrimitiveField).forEach((field) => { -%>
  public <%= field.name %>: <%= field.type %>;
<% }); -%>

<% fields.filter(isAssociationField).forEach((field) => { -%>
  protected <%= field.name %>?: <%= getAssociationStrings(field).entityFieldType %>;
<% }); -%>

  public constructor(
    model: <%= modelName %>,
    group: <%= getEntityStrings().baseClass %>[],
    lock: AsyncLock,
  ) {
    super(group, lock);

<% fields.filter(isPrimitiveField).forEach((field) => { -%>
    this.<%= field.name %> = model.<%= field.name %><%= field.cast ? ` as ${field.type}` : '' %>;
<% }); -%>

    this.initialize();
  }
<% if (!internal) { -%>

  public static defaultFieldRequest: <%= getEntityStrings().fieldRequestClass %> = {
<% fields.filter((field) => isExternalField(field) && isSyncField(field)).forEach((field) => { -%>
    <%= field.name %>: true,
<% }); -%>
  };

  public async present(request?: <%= getEntityStrings().fieldRequestClass %> | boolean): Promise<<%= getEntityStrings().responseClass %>> {
    if (request === false) {
      throw new Error('unprocessable field request');
    }
    const fieldRequest = request === true || request === undefined ? <%= getEntityStrings().baseClass %>.defaultFieldRequest : request;
    return {
<% fields.filter(isExternalField).forEach((field) => { -%>
      <%= field.name %>: <%- getFieldPresenter(field) %>,
<% }); -%>
    };
  }
<% } -%>
<% if (fields.some(isAssociationField)) { -%>

  /** associations */
<% } -%>
<% fields.filter(isAssociationField).forEach((field) => { -%>

  protected <%= field.name %>Params: LoadParams<<%= getEntityStrings().baseClass %>, <%= getAssociationStrings(field).entityClass %>> = {
    name: '<%= getFieldParamsName(field) %>',
    filter: (one: <%= getEntityStrings().baseClass %>) => one.<%= field.name %> === undefined,
    // TODO: build your association data loader
    // loader: async (array: <%= getEntityStrings().baseClass %>[]) => {
<% if (hasSourceKey(field)) { -%>
<% getSourceFields(field).forEach((sourceField) => { -%>
    //   const <%= sourceField.name %>s = buildUniqueNonNullArray(array, (one) => one.<%= getFieldGetterName(sourceField) %>);
<% }); -%>
    //   // TODO: load models with the above keys
<% } -%>
    //   const loadedModels = ...;
    //   return <%= getAssociationStrings(field).entityClass %>.fromArray(loadedModels);
    // },
<% if (!hasAssociationKeys(field)) { -%>
    // TODO: build your association data setter
<% } -%>
    <%= hasAssociationKeys(field) ? '' : '// ' %>setter: (array: <%= getEntityStrings().baseClass %>[], loaded: <%= getAssociationStrings(field).entityClass %>[]) => {
<% if (isArrayField(field)) { -%>
    <%= hasAssociationKeys(field) ? '' : '// ' %>  const map = buildArrayMap(
<% } else { -%>
    <%= hasAssociationKeys(field) ? '' : '// ' %>  const map = buildObjectMap(
<% } -%>
    <%= hasAssociationKeys(field) ? '' : '// ' %>    loaded,
    <%= hasAssociationKeys(field) ? '' : '// ' %>    (one) => <%- hasTargetKey(field) ? getTargetKey(field) : '\'TODO: map your target entity to key\'' %>,
    <%= hasAssociationKeys(field) ? '' : '// ' %>    (one) => one
    <%= hasAssociationKeys(field) ? '' : '// ' %>  );
    <%= hasAssociationKeys(field) ? '' : '// ' %>  array.forEach((one) => (one.<%= field.name %> = map.get(<%- hasSourceKey(field) ? getSourceKey(field) : '\'TODO: map your source entity to key\'' %>)<%= isArrayField(field) ? ' ?? []' : isNullableField(field) ? ' ?? null' : '!' %>));
    <%= hasAssociationKeys(field) ? '' : '// ' %>},
  };

  protected async load<%= toTitleCase(field.name) %>(): Promise<void> {
    await this.load(this.<%= field.name %>Params);
  }

  public async get<%= toTitleCase(field.name) %>(): Promise<<%= getAssociationStrings(field).entityFieldType %>> {
    if (this.<%= field.name %> !== undefined) {
      return this.<%= field.name %>;
    }
    await this.load<%= toTitleCase(field.name) %>();
    return this.<%= field.name %>!;
  }

  public set<%= toTitleCase(field.name) %>(<%= field.name %>?: <%= getAssociationStrings(field).entityFieldType %>): void {
    this.<%= field.name %> = <%= field.name %>;
  }
<% }); -%>
<% if (fields.some(isComputedSyncField)) { -%>

  /** computed sync fields */
<% } -%>
<% fields.filter(isComputedSyncField).forEach((field) => { -%>

  public get<%= toTitleCase(field.name) %>(): <%= field.type %> {
    throw new Error('not implemented');
  }
<% }); -%>
<% if (fields.some(isComputedAsyncField)) { -%>

  /** computed async fields */
<% } -%>
<% fields.filter(isComputedAsyncField).forEach((field) => { -%>

  public async get<%= toTitleCase(field.name) %>(): Promise<<%= field.type %>> {
    throw new Error('not implemented');
  }
<% }); -%>
}
