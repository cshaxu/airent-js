<% /** string utils */ -%>
<% function toKababCase(string) {
  return string
    .replace(/_/g, '-')
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .toLowerCase();
} -%>
<% function toTitleCase(string) { return string.charAt(0).toUpperCase() + string.slice(1); } -%>
<% /** field utils */ -%>
<% function isAssociationField(field) { return field.strategy === 'association'; } -%>
<% function isComputedSyncField(field) { return field.strategy === 'computed_sync'; } -%>
<% function isComputedAsyncField(field) { return field.strategy === 'computed_async'; } -%>
<% function isImportableField(field) { return isAssociationField(field) || field.imports?.length; } -%>
<% function isPrimitiveField(field) { return field.strategy === 'primitive'; } -%>
<% function isExternalField(field) { return !field.internal; } -%>
<% function isSyncField(field) { return isPrimitiveField(field) || isComputedSyncField(field); } -%>
<% /** class utils */ -%>
<% function getModuleSuffix() { return isModule ? '.js' : ''; } -%>
<% function getEntityStrings() {
  const prefix = toKababCase(entityName);
  const suffix = getModuleSuffix();
  return {
    entName: entityName,
    baseClass: `${entityName}EntityBase`,
    entityClass: `${entityName}Entity`,
    fieldRequestClass: `${entityName}FieldRequest`,
    responseClass: `${entityName}Response`,
    basePackage: `${prefix}-base${suffix}`,
    entityPackage: `${prefix}${suffix}`,
    typePackage: `${prefix}-type${suffix}`,
  };
} -%>
<% function getAssociationStrings(field) {
  const entName = toTitleCase(field.type.split("|")[0].split("[]")[0].trim());

  const prefix = toKababCase(entName);
  const suffix = getModuleSuffix();

  const entityClass = `${entName}Entity`;
  const responseClass = `${entName}Response`;

  return {
    entName,
    entityClass,
    fieldRequestClass: `${entName}FieldRequest`,
    responseClass,
    entityPackage: `${prefix}${suffix}`,
    typePackage: `${prefix}-type${suffix}`,
    entityFieldType: field.type.replace(entName, entityClass),
    responseFieldType: field.type.replace(entName, responseClass),
  };
} -%>
<% /** base template specific utils */ -%>
<% function getModelClass() {
  if (!model._import) {
    return '';
  }
  const prefix =
    (model._import.name && model._import.name !== model.name) 
      ? `${model._import.name} as ` : '';
  return `${prefix}${model.name}`;
} -%>
<% function getFieldPresenter(field) {
  const condition = `fieldRequest?.${field.name}`;
  let getter = 'undefined';

  if (isPrimitiveField(field)) {
    getter = `this.${field.name}`;
  }
  const getterFunction = `this.get${toTitleCase(field.name)}()`;
  if (isComputedSyncField(field)) {
    getter = getterFunction;
  } else if (isComputedAsyncField(field)) {
    getter = `await ${getterFunction}`;
  } else if (isAssociationField(field)) {
    if (field.type.endsWith('[]')) {
      getter = `await ${getterFunction}.then((a) => Promise.all(a.map((one) => one.present(${condition}))))`;
    } else if (field.type.endsWith('[] | null')) {
      getter = `await ${getterFunction}.then((a) => a ? Promise.all(a.map((one) => one.present(${condition})) : Promise.resolve(null)))`;
    } else if (field.type.endsWith(' | null')) {
      getter = `await ${getterFunction}.then((one) => one ? one.present(${condition}) : Promise.resolve(null))`;
    } else {
      getter = `await ${getterFunction}.then((one) => one.present(${condition}))`;
    }
  }
  
  return `${condition} ? ${getter} : undefined`;
} -%>
<% /** base template follows */ -%>
import { AsyncLock, BaseEntity } from '<%= airentPackage %>';
<% if (model._import) { -%>

/** model */
import { <%= getModelClass() %> } from '<%= model._import.package %>';
<% } -%>
<% if (!internal) { -%>

/** response */
import { <%= getEntityStrings().fieldRequestClass %>, <%= getEntityStrings().responseClass %> } from './<%= getEntityStrings().typePackage %>';
<% } -%>
<% if (fields.some(isAssociationField)) { -%>

/** associations */
<% } -%>
<% fields.filter(isAssociationField).forEach((field) => { -%>
import { <%= getAssociationStrings(field).entityClass %> } from '../<%= getAssociationStrings(field).entityPackage %>';
<% }); -%>
<% if (fields.some((field) => isImportableField(field) && !isAssociationField(field))) { -%>

/** fields */
<% } -%>
<% fields
  .filter((field) => isImportableField(field) && !isAssociationField(field))
  .flatMap((field) => field.imports)
  .filter((_import) => _import.name)
  .forEach((_import) => { -%>
import { <%= _import.name %> } from '<%= _import.package %>';
<% }); -%>

export class <%= getEntityStrings().baseClass %> extends BaseEntity<
  <%= model.name %><%= internal ? '' : `, ${getEntityStrings().fieldRequestClass}, ${getEntityStrings().responseClass}` %>
> {
<% fields.filter(isPrimitiveField).forEach((field) => { -%>
  public <%= field.name %>: <%= field.type %>;
<% }); -%>

<% fields.filter(isAssociationField).forEach((field) => { -%>
  protected <%= field.name %>?: <%= getAssociationStrings(field).entityFieldType %>;
<% }); -%>

  public constructor(
    model: <%= model.name %>,
    group: <%= getEntityStrings().baseClass %>[],
    lock: AsyncLock,
  ) {
    super(group, lock);

<% fields.filter(isPrimitiveField).forEach((field) => { -%>
    this.<%= field.name %> = model.<%= field.name %><%= field.cast ? ` as ${field.type}` : '' %>;
<% }); -%>
  }
<% if (!internal) { -%>

  protected defaultFieldRequest: <%= getEntityStrings().fieldRequestClass %> = {
<% fields.filter((field) => isExternalField(field) && isSyncField(field)).forEach((field) => { -%>
    <%= field.name %>: true,
<% }); -%>
  };

  public async present(request?: <%= getEntityStrings().fieldRequestClass %> | boolean): Promise<<%= getEntityStrings().responseClass %>> {
    if (request === false) {
      throw new Error('unprocessable field request');
    }
    const fieldRequest = request === true || request === undefined ? this.defaultFieldRequest : request;
    return {
<% fields.filter(isExternalField).forEach((field) => { -%>
      <%= field.name %>: <%- getFieldPresenter(field) %>,
<% }); -%>
    };
  }
<% } -%>
<% if (fields.some(isAssociationField)) { -%>

  /** associations */
<% } -%>
<% fields.filter(isAssociationField).forEach((field) => { -%>

  protected <%= field.name %>Params = { name: '<%= getEntityStrings().baseClass %>.<%= field.name %>'};

  protected async load<%= toTitleCase(field.name) %>(): Promise<void> {
    await this.load(this.<%= field.name %>Params);
  }

  public async get<%= toTitleCase(field.name) %>(): Promise<<%= getAssociationStrings(field).entityFieldType %>> {
    if (this.<%= field.name %> !== undefined) {
      return this.<%= field.name %>;
    }
    await this.load<%= toTitleCase(field.name) %>();
    return this.<%= field.name %>!;
  }

  public set<%= toTitleCase(field.name) %>(<%= field.name %>?: <%= getAssociationStrings(field).entityFieldType %>): void {
    this.<%= field.name %> = <%= field.name %>;
  }
<% }); -%>
<% if (fields.some(isComputedSyncField)) { -%>

  /** computed sync fields */
<% } -%>
<% fields.filter(isComputedSyncField).forEach((field) => { -%>

  public get<%= toTitleCase(field.name) %>(): <%= field.type %> {
    throw new Error('not implemented');
  }
<% }); -%>
<% if (fields.some(isComputedAsyncField)) { -%>

  /** computed async fields */
<% } -%>
<% fields.filter(isComputedAsyncField).forEach((field) => { -%>

  public async get<%= toTitleCase(field.name) %>(): Promise<<%= field.type %>> {
    throw new Error('not implemented');
  }
<% }); -%>
}
