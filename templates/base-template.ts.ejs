import { AsyncLock, BaseEntity } from 'airent';

<% function isPrimitiveField(field) { return field.strategy === 'primitive'; } %>
<% function isAssociationField(field) { return field.strategy === 'association'; } %>
<% function isComputedSyncField(field) { return field.strategy === 'computed_sync'; } %>
<% function isComputedAsyncField(field) { return field.strategy === 'computed_async'; } %>
<% function isImportableField(field) { return isAssociationField(field) || field.imports?.length; } %>
<% function toKababCase(string) { return string.replace(/_/g, '-').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(); } %>
<% function toTitleCase(string) { return string.charAt(0).toUpperCase()+ string.slice(1); } %>

<% if (model._import) { %>
/** model */
import { <%= model._import.name && model._import.name !== model.name ? `${model._import.name} as ` : '' %><%= model.name %> } from '<%= model._import.package %>';<% } %>
<% if (response?._import) { %>
/** response */
import { <%= response._import.name && response._import.name !== response.name ? `${response._import.name} as ` : '' %><%= response.name %> } from '<%= response._import.package %>';<% } %>

<% if (fields.some(isAssociationField)) { %>/** associations */<% } %>
<% fields.filter(isAssociationField).forEach((field) => { %>import { <%= field.type.replace(/\[|\]/g, '') %> } from '../<%= toKababCase(field.type.split('Entity')[0]) %>.js';<% }); %>

<% if (fields.some((field) => isImportableField(field) && !isAssociationField(field))) { %>/** fields */<% } %>
<% fields.filter((field) => isImportableField(field) && !isAssociationField(field)).flatMap((field) => field.imports).filter((_import) => _import.name).forEach((_import) => { %>import { <%= _import.name %> } from '<%= _import.package %>';<% }); %>

export class <%= entityName %>EntityBase extends BaseEntity<<%= model.name %><%= response ? `, ${response.name}` : '' %>> {
<% fields.filter(isPrimitiveField).forEach((field) => { %>  public <%= field.name %>: <%= field.type %>;
<% }); %>
<% fields.filter(isAssociationField).forEach((field) => { %>  protected <%= field.name %>?: <%= field.type %>;
<% }); %>

  public constructor(
    model: <%= model.name %>,
    group: <%= entityName %>EntityBase[],
    lock: AsyncLock,
  ) {
    super(group, lock);
<% fields.filter(isPrimitiveField).forEach((field) => { %>
    this.<%= field.name %> = model.<%= field.name %><%= field.cast ? ` as ${field.type}` : '' %>;<% }); %>
  }
<% if (fields.some(isAssociationField)) { %>
  /** associations */<% } %>
<% fields.filter(isAssociationField).forEach((field) => { %>
  protected <%= field.name %>Params = {};

  protected async load<%= toTitleCase(field.name) %>(): Promise<void> {
    await this.load(this.<%= field.name %>Params);
  }

  public async get<%= toTitleCase(field.name) %>(): Promise<<%= field.type %>> {
    if (this.<%= field.name %> !== undefined) {
      return this.<%= field.name %>;
    }
    await this.load<%= toTitleCase(field.name) %>();
    return this.<%= field.name %>!;
  }

  public set<%= toTitleCase(field.name) %>(<%= field.name %>?: <%= field.type %>): void {
    this.<%= field.name %> = <%= field.name %>;
  }
<% }); %>
<% if (fields.some(isComputedSyncField)) { %>
  /** computed sync fields */<% } %>
  <% fields.filter(isComputedSyncField).forEach((field) => { %>
  public get<%= toTitleCase(field.name) %>(): <%= field.type %> {
    throw new Error('not implemented');
  }
<% }); %>
<% if (fields.some(isComputedAsyncField)) { %>
  /** computed async fields */<% } %>
<% fields.filter(isComputedAsyncField).forEach((field) => { %>
  public async get<%= toTitleCase(field.name) %>(): Promise<<%= field.type %>> {
    throw new Error('not implemented');
  }
<% }); %>
}
