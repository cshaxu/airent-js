import { AsyncLock, BaseEntity, LoadParams, toArrayMap, toObjectMap } from '<%= airentPackage %>';
<% if (!internal || fields.some(isInternalType)) { -%>

/** generated */
import {
  <%= getThisEntityStrings().fieldRequestClass %>,
  <%= getThisEntityStrings().responseClass %>,
<% types.filter(isInternalType).forEach((type) => { -%>
  <%= getTypeStrings(type).typeName %>,
<% }); -%>
} from './<%= getThisEntityStrings().typePackage %>';
<% } -%>
<% if (types.some(isEntityType)) { -%>

/** associations */
<% types.filter(isEntityType).forEach((type) => { -%>
import { <%= getTypeStrings(type).entityClass %> } from '../<%= getTypeStrings(type).entityPackage %>';
<% }); -%>
<% } -%>
<% if (types.some(isImportableType)) { -%>

/** external types */
<% types.filter(isImportableType).forEach((type) => { -%>
import { <%= getTypeStrings(type).externalClass %> } from '<%= getTypeStrings(type).externalPackage %>';
<% }); -%>
<% } -%>

export class <%= getThisEntityStrings().baseClass %> extends BaseEntity<
  <%= modelName %><%= internal ? '' : `, ${getThisEntityStrings().fieldRequestClass}, ${getThisEntityStrings().responseClass}` %>
> {
<% fields.filter(isPrimitiveField).forEach((field) => { -%>
  public <%= field.name %>: <%= getFieldStrings(field).fieldType %>;
<% }); -%>

<% fields.filter(isAssociationField).forEach((field) => { -%>
  protected <%= field.name %>?: <%= getOtherEntityStrings(field).entityFieldType %>;
<% }); -%>

  public constructor(
    model: <%= modelName %>,
    group: <%= getThisEntityStrings().baseClass %>[],
    lock: AsyncLock,
  ) {
    super(group, lock);

<% fields.filter(isPrimitiveField).forEach((field) => { -%>
    this.<%= field.name %> = model.<%= field.name %><%= field.cast ? ` as ${getFieldStrings(field).fieldType}` : '' %>;
<% }); -%>

    this.initialize();
  }
<% if (!internal) { -%>

  public static defaultFieldRequest: <%= getThisEntityStrings().fieldRequestClass %> = {
<% fields.filter((field) => isExternalField(field) && isSyncField(field)).forEach((field) => { -%>
    <%= field.name %>: true,
<% }); -%>
  };

  public async present(request?: <%= getThisEntityStrings().fieldRequestClass %> | boolean): Promise<<%= getThisEntityStrings().responseClass %>> {
    if (request === false) {
      throw new Error('unprocessable field request');
    }
    const fieldRequest = request === true || request === undefined ? <%= getThisEntityStrings().baseClass %>.defaultFieldRequest : request;
    return {
<% fields.filter(isExternalField).forEach((field) => { -%>
      <%= field.name %>: <%- getFieldPresenter(field) %>,
<% }); -%>
    };
  }
<% } -%>
<% if (fields.some(isAssociationField)) { -%>

  /** associations */
<% } -%>
<% fields.filter(isAssociationField).forEach((field) => { -%>

  protected <%= field.name %>Params: LoadParams<<%= getThisEntityStrings().baseClass %>, <%= getOtherEntityStrings(field).entityClass %>> = {
    name: '<%= getFieldParamsName(field) %>',
    filter: (one: <%= getThisEntityStrings().baseClass %>) => one.<%= field.name %> === undefined,
    // TODO: build your association data loader
    // loader: async (array: <%= getThisEntityStrings().baseClass %>[]) => {
<% if (hasSourceKey(field)) { -%>
<% getSourceFields(field).forEach((sourceField) => { -%>
    //   const <%= sourceField.name %>s = unique((nonNull(array.map((one) => <%= getFieldGetter('one.', sourceField) %>))));
<% }); -%>
    //   // TODO: load models with the above keys
<% } -%>
    //   const loadedModels = ...;
    //   return <%= getOtherEntityStrings(field).entityClass %>.fromArray(loadedModels);
    // },
<% if (!hasAssociationKeys(field)) { -%>
    // TODO: build your association data setter
<% } -%>
    <%= hasAssociationKeys(field) ? '' : '// ' %>setter: (array: <%= getThisEntityStrings().baseClass %>[], loaded: <%= getOtherEntityStrings(field).entityClass %>[]) => {
<% if (isArrayField(field)) { -%>
    <%= hasAssociationKeys(field) ? '' : '// ' %>  const map = toArrayMap(
<% } else { -%>
    <%= hasAssociationKeys(field) ? '' : '// ' %>  const map = toObjectMap(
<% } -%>
    <%= hasAssociationKeys(field) ? '' : '// ' %>    loaded,
    <%= hasAssociationKeys(field) ? '' : '// ' %>    (one) => <%- hasTargetKey(field) ? getTargetKey(field) : '\'TODO: map your target entity to key\'' %>,
    <%= hasAssociationKeys(field) ? '' : '// ' %>    (one) => one
    <%= hasAssociationKeys(field) ? '' : '// ' %>  );
    <%= hasAssociationKeys(field) ? '' : '// ' %>  array.forEach((one) => (one.<%= field.name %> = <%= getNullableCondition(field) %>map.get(<%- hasSourceKey(field) ? getSourceKey(field) : '\'TODO: map your source entity to key\'' %>)<%= isArrayField(field) ? ' ?? []' : isNullableField(field) ? ' ?? null' : '!' %>));
    <%= hasAssociationKeys(field) ? '' : '// ' %>},
  };

  protected async load<%= toTitleCase(field.name) %>(): Promise<void> {
    await this.load(this.<%= field.name %>Params);
  }

  public async <%= getFieldStrings(field).fieldGetterName %>: Promise<<%= getFieldStrings(field).fieldType %>> {
    if (this.<%= field.name %> !== undefined) {
      return this.<%= field.name %>;
    }
    await this.load<%= toTitleCase(field.name) %>();
    return this.<%= field.name %>!;
  }

  public set<%= toTitleCase(field.name) %>(<%= field.name %>?: <%= getFieldStrings(field).fieldType %>): void {
    this.<%= field.name %> = <%= field.name %>;
  }
<% }); -%>
<% if (fields.some(isComputedSyncField)) { -%>

  /** computed sync fields */
<% } -%>
<% fields.filter(isComputedSyncField).forEach((field) => { -%>

  public <%= getFieldStrings(field).fieldGetterName %>: <%= getFieldStrings(field).fieldType %> {
    throw new Error('not implemented');
  }
<% }); -%>
<% if (fields.some(isComputedAsyncField)) { -%>

  /** computed async fields */
<% } -%>
<% fields.filter(isComputedAsyncField).forEach((field) => { -%>

  public async <%= getFieldStrings(field).fieldGetterName %>: Promise<<%= getFieldStrings(field).fieldType %>> {
    throw new Error('not implemented');
  }
<% }); -%>
}
