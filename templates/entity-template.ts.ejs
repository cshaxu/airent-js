import { toArrayMap, toObjectMap, nonNull, unique } from '<%= airentPackage %>';
import { <%= getThisEntityStrings().baseClass %> } from './generated/<%= getThisEntityStrings().basePackage %>';
<% if (!internal || fields.some(isInternalType)) { -%>
import {
<% if (!internal) { -%>
  <%= getThisEntityStrings().fieldRequestClass %>,
  <%= getThisEntityStrings().responseClass %>,
<% } -%>
<% types.filter(isInternalType).forEach((type) => { -%>
  <%= getTypeStrings(type).typeName %>,
<% }); -%>
} from './generated/<%= getThisEntityStrings().typePackage %>';
<% } -%>
<% types.filter(isEntityType).forEach((type) => { -%>
import { <%= getTypeStrings(type).entityClass %> } from './<%= getTypeStrings(type).entityPackage %>';
<% }); -%>
<% types.filter(isExternalType).forEach((type) => { -%>
import { <%= getTypeStrings(type).externalClass %> } from '<%= getTypeStrings(type).externalPackage %>';
<% }); -%>

export class <%= getThisEntityStrings().entityClass %> extends <%= getThisEntityStrings().baseClass %> {
<% if (fields.some(isAssociationField)) { -%>
  protected initialize() {
    super.initialize();

    /** associations */
<% fields.filter(isAssociationField).forEach((field) => { -%>

    this.<%= field.name %>Params.loader = async (array: <%= getThisEntityStrings().baseClass %>[]) => {    
<% if (hasSourceKey(field)) { -%>
<% getSourceFields(field).forEach((sourceField) => { -%>
      const <%= sourceField.name %>s = unique((nonNull(array.map((one) => one.<%= getFieldGetterName(sourceField) %>))));
<% }); -%>
      // TODO: load models with the above keys
<% } else { -%>
      // TODO: build your association data loader
<% } -%>
      const loadedModels = [];
      return <%= getOtherEntityStrings(field).entityClass %>.fromArray(loadedModels);
    };
<% if (!hasAssociationKeys(field)) { -%>

    this.<%= field.name %>Params.setter = ((array: <%= getThisEntityStrings().entityClass %>[], loaded: <%= getOtherEntityStrings(field).entityClass %>[]) => {
<% if (isArrayField(field)) { -%>
      const map = buildArrayMap(
<% } else { -%>
      const map = buildObjectMap(
<% } -%>
        loaded,
        (one) => <%- hasTargetKey(field) ? getTargetKey(field) : '\'TODO: map your target entity to key\'' %>,
        (one) => one
      );
      array.forEach((one) => (one.<%= field.name %> = <%= getNullableCondition(field) %>map.get(<%- hasSourceKey(field) ? getSourceKey(field) : '\'TODO: map your source entity to key\'' %>)<%= isArrayField(field) ? ' ?? []' : isNullableField(field) ? ' ?? null' : '!' %>));
    }) as (array: <%= getThisEntityStrings().baseClass %>[], loaded: <%= getOtherEntityStrings(field).entityClass %>[]) => Promise<void>;
<% } -%>
<% }); -%>
  }
<% } -%>
<% if (fields.some(isComputedSyncField)) { -%>

  /** computed sync fields */
<% } -%>
<% fields.filter(isComputedSyncField).forEach((field) => { -%>

  public <%= getFieldStrings(field).fieldGetterName %>: <%= getFieldStrings(field).fieldType %> {
    throw new Error('not implemented');
  }
<% }); -%>
<% if (fields.some(isComputedAsyncField)) { -%>

  /** computed async fields */
<% } -%>
<% fields.filter(isComputedAsyncField).forEach((field) => { -%>

  public async <%= getFieldStrings(field).fieldGetterName %>: Promise<<%= getFieldStrings(field).fieldType %>> {
    throw new Error('not implemented');
  }
<% }); -%>
}
