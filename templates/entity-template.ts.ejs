<%
/** string utils */

function toKababCase(string) {
  return string
    .replace(/_/g, '-')
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .toLowerCase();
}

function toTitleCase(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

/** field utils */

function isAssociationField(field) { return field.strategy === 'association'; }
function isComputedSyncField(field) { return field.strategy === 'computed_sync'; }
function isComputedAsyncField(field) { return field.strategy === 'computed_async'; }
function isImportableField(field) { return isAssociationField(field) || field.imports?.length; }
function isPrimitiveField(field) { return field.strategy === 'primitive'; }
function isExternalField(field) { return !field.internal; }
function isSyncField(field) { return isPrimitiveField(field) || isComputedSyncField(field); }
function isArrayField(field) { return field.type.endsWith('[]'); }
function isNullableField(field) { return field.type.endsWith(' | null'); }

function getFieldGetterName(field) {
  if (isPrimitiveField(field)) {
    return `${field.name}`;
  }
  return `get${toTitleCase(field.name)}()`;
}

function getFieldGetter(prefix, field) {
  const getterName = `${prefix}${getFieldGetterName(field)}`;
  if (isSyncField(field)) {
    return getterName;
  } else {
    return `await ${getterName}`;
  }
}

function queryField(fieldName) {
  return fields.find((field) => field.name === fieldName);
}

function hasAssociationKeys(field) {
  return getSourceFields(field).length && field.targetFields?.length;
}

function getSourceFields(field) {
  return (field.sourceFields ?? [])
    .map(queryField)
    .filter(Boolean)
    .filter(isSyncField);
}

function getSourceAssociationKey(field) {
  const getters = getSourceFields(field)
    .map((sf) => getFieldGetter('one.', sf))
  if (getters.length === 1) {
    return getters[0];
  }
  return '`' + getters.map((getter) => `\${${getter}}`).join('*') + '`';
}

function getTargetAssociationKey(field) {
  const getters = (field.targetFields ?? [])
    .map((fieldName) => `one.${fieldName}`);
  if (getters.length === 1) {
    return getters[0];
  }
  return '`' + getters.map((getter) => `\${${getter}}`).join('*') + '`';
}

/** class utils */

function getModuleSuffix() { return isModule ? '.js' : ''; }

function getEntityStrings() {
  const prefix = toKababCase(entityName);
  const suffix = getModuleSuffix();
  return {
    entName: entityName,
    baseClass: `${entityName}EntityBase`,
    entityClass: `${entityName}Entity`,
    fieldRequestClass: `${entityName}FieldRequest`,
    responseClass: `${entityName}Response`,
    basePackage: `${prefix}-base${suffix}`,
    entityPackage: `${prefix}${suffix}`,
    typePackage: `${prefix}-type${suffix}`,
  };
}

function getAssociationStrings(field) {
  const entName = toTitleCase(field.type.split("|")[0].split("[]")[0].trim());

  const prefix = toKababCase(entName);
  const suffix = getModuleSuffix();

  const entityClass = `${entName}Entity`;
  const responseClass = `${entName}Response`;

  return {
    entName,
    entityClass,
    fieldRequestClass: `${entName}FieldRequest`,
    responseClass,
    entityPackage: `${prefix}${suffix}`,
    typePackage: `${prefix}-type${suffix}`,
    entityFieldType: field.type.replace(entName, entityClass),
    responseFieldType: field.type.replace(entName, responseClass),
  };
}

/** association utils */

function getFieldParamsName(field) {
  const className = getEntityStrings().entityClass;
  const fieldName = field.name;
  return `${className}.${fieldName}`;
}

/** entity template follows */
-%>
import { buildArrayMap, buildObjectMap, buildUniqueNonNullArray } from '<%= airentPackage %>';
import { <%= getEntityStrings().baseClass %> } from './generated/<%= getEntityStrings().basePackage %>';
<% fields.filter(isAssociationField).forEach((field) => { -%>
import { <%= getAssociationStrings(field).entityClass %> } from './<%= getAssociationStrings(field).entityPackage %>';
<% }); -%>
<% fields
  .filter((field) => isImportableField(field) && !isAssociationField(field))
  .flatMap((field) => field.imports)
  .filter((_import) => _import.name)
  .forEach((_import) => { -%>
import { <%= _import.name %> } from '<%= _import.package %>';
<% }); -%>

export class <%= getEntityStrings().entityClass %> extends <%= getEntityStrings().baseClass %> {
<% if (fields.some(isAssociationField)) { -%>
  protected initialize() {
    super.initialize();

    /** associations */
<% fields.filter(isAssociationField).forEach((field) => { -%>

    this.<%= field.name %>Params.loader = async (array: <%= getEntityStrings().baseClass %>[]) => {    
<% if (hasAssociationKeys(field)) { -%>
<% getSourceFields(field).forEach((sourceField) => { -%>
      const <%= sourceField.name %>s = buildUniqueNonNullArray(array, (one) => one.<%= getFieldGetterName(sourceField) %>);
<% }); -%>
      // TODO: load models with the above keys
<% } else { -%>
      // TODO: build your association data loader
<% } -%>
      const loadedModels = [];
      return <%= getAssociationStrings(field).entityClass %>.fromArray(loadedModels);
    };
<% if (!hasAssociationKeys(field)) { -%>

    this.<%= field.name %>Params.setter = (array: <%= getEntityStrings().baseClass %>[], loaded: <%= getAssociationStrings(field).entityClass %>[]) => {
<% if (isArrayField(field)) { -%>
      const map = buildArrayMap(
<% } else { -%>
      const map = buildObjectMap(
<% } -%>
        loaded,
        (one) => '', // TODO: map your target entities to keys
        (one) => one
      );
      // TODO: map your source entities to keys
      array.forEach((one) => (one.<%= field.name %> = map.get('')<%= isArrayField(field) ? ' ?? []' : isNullableField(field) ? ' ?? null' : '!' %>));
    };
<% } -%>
<% }); -%>
  }
<% } -%>
<% if (fields.some(isComputedSyncField)) { -%>

  /** computed sync fields */
<% } -%>
<% fields.filter(isComputedSyncField).forEach((field) => { -%>

  public get<%= toTitleCase(field.name) %>(): <%= field.type %> {
    throw new Error('not implemented');
  }
<% }); -%>
<% if (fields.some(isComputedAsyncField)) { -%>

  /** computed async fields */
<% } -%>
<% fields.filter(isComputedAsyncField).forEach((field) => { -%>

  public async get<%= toTitleCase(field.name) %>(): Promise<<%= field.type %>> {
    throw new Error('not implemented');
  }
<% }); -%>
}
