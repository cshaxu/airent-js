<% function isPrimitiveField(field) { return field.strategy === 'primitive'; } %>
<% function isAssociationField(field) { return field.strategy === 'association'; } %>
<% function isComputedSyncField(field) { return field.strategy === 'computed_sync'; } %>
<% function isComputedAsyncField(field) { return field.strategy === 'computed_async'; } %>
<% function isComputedField(field) { return isComputedSyncField(field) || isComputedAsyncField(field); } %>
<% function isImportableField(field) { return isAssociationField(field) || field.imports?.length; } %>
<% function toKababCase(string) { return string.replace(/_/g, '-').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(); } %>
<% function toTitleCase(string) { return string.charAt(0).toUpperCase()+ string.slice(1); } %>

import { <%= entityName %>EntityBase } from './generated/<%= toKababCase(entityName) %>.js';
<% if (response?._import) { %>import { <%= response._import.name && response._import.name !== response.name ? `${response._import.name} as ` : '' %><%= response.name %> } from '<%= response._import.package %>';<% } %>
<% fields.filter(isAssociationField).forEach((field) => { %>import { <%= field.type.replace(/\[|\]/g, '') %> } from './<%= toKababCase(field.type.split('Entity')[0]) %>.js';
<% }); %>
<% fields.filter((field) => isImportableField(field) && isComputedField(field)).flatMap((field) => field.imports).filter((_import) => _import.name).forEach((_import) => { %>import { <%= _import.name %> } from '<%= _import.package %>';
<% }); %>

export class <%= entityName %>Entity extends <%= entityName %>EntityBase {
<% if (response) { %>
  public async present(format?: string): Promise<<%= response.name %>> {
    throw new Error('not implemented');
  }
<% } %>
<% if (fields.some(isAssociationField)) { %>
  /** associations */<% } %>
<% fields.filter(isAssociationField).forEach((field) => { %>
  protected <%= field.name %>Params = {
    before: undefined,
    filter: (one: <%= entityName %>Entity) => {
      throw new Error('not implemented');
    },
    loader: async (array: <%= entityName %>Entity[]) => {
      throw new Error('not implemented');
    },
    setter: (array: <%= entityName %>Entity[], loaded: <%= field.type.replace(/\[|\]/g, '') %>[]) => {
      throw new Error('not implemented');
    },
    after: undefined,
  };
<% }); %>
<% if (fields.some(isComputedSyncField)) { %>
  /** computed sync fields */<% } %>
  <% fields.filter(isComputedSyncField).forEach((field) => { %>
  public get<%= toTitleCase(field.name) %>(): <%= field.type %> {
    throw new Error('not implemented');
  }
<% }); %>
<% if (fields.some(isComputedAsyncField)) { %>
  /** computed async fields */<% } %>
<% fields.filter(isComputedAsyncField).forEach((field) => { %>
  public async get<%= toTitleCase(field.name) %>(): Promise<<%= field.type %>> {
    throw new Error('not implemented');
  }
<% }); %>
}
