<% /** string utils */ -%>
<% function toKababCase(string) {
  return string
    .replace(/_/g, '-')
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .toLowerCase();
} -%>
<% function toTitleCase(string) { return string.charAt(0).toUpperCase() + string.slice(1); } -%>
<% /** field utils */ -%>
<% function isAssociationField(field) { return field.strategy === 'association'; } -%>
<% function isComputedSyncField(field) { return field.strategy === 'computed_sync'; } -%>
<% function isComputedAsyncField(field) { return field.strategy === 'computed_async'; } -%>
<% function isImportableField(field) { return isAssociationField(field) || field.imports?.length; } -%>
<% /** class utils */ -%>
<% function getModuleSuffix() { return isModule ? '.js' : ''; } -%>
<% function getEntityStrings() {
  const prefix = toKababCase(entityName);
  const suffix = getModuleSuffix();
  return {
    entName: entityName,
    baseClass: `${entityName}EntityBase`,
    entityClass: `${entityName}Entity`,
    fieldRequestClass: `${entityName}FieldRequest`,
    responseClass: `${entityName}Response`,
    basePackage: `${prefix}-base${suffix}`,
    entityPackage: `${prefix}${suffix}`,
    typePackage: `${prefix}-type${suffix}`,
  };
} -%>
<% function getAssociationStrings(field) {
  const entName = toTitleCase(field.type.split("|")[0].split("[]")[0].trim());

  const prefix = toKababCase(entName);
  const suffix = getModuleSuffix();

  const entityClass = `${entName}Entity`;
  const responseClass = `${entName}Response`;

  return {
    entName,
    entityClass,
    fieldRequestClass: `${entName}FieldRequest`,
    responseClass,
    entityPackage: `${prefix}${suffix}`,
    typePackage: `${prefix}-type${suffix}`,
    entityFieldType: field.type.replace(entName, entityClass),
    responseFieldType: field.type.replace(entName, responseClass),
  };
} -%>
<% /** entity template follows */ -%>
import { <%= getEntityStrings().baseClass %> } from './generated/<%= getEntityStrings().basePackage %>';
<% fields.filter(isAssociationField).forEach((field) => { -%>
import { <%= getAssociationStrings(field).entityClass %> } from './<%= getAssociationStrings(field).entityPackage %>';
<% }); -%>
<% fields
  .filter((field) => isImportableField(field) && !isAssociationField(field))
  .flatMap((field) => field.imports)
  .filter((_import) => _import.name)
  .forEach((_import) => { -%>
import { <%= _import.name %> } from '<%= _import.package %>';
<% }); -%>

export class <%= getEntityStrings().entityClass %> extends <%= getEntityStrings().baseClass %> {
<% if (fields.some(isAssociationField)) { -%>

  /** associations */
<% } -%>
<% fields.filter(isAssociationField).forEach((field) => { -%>

  protected <%= field.name %>Params = {
    name: '<%= getEntityStrings().entityClass %>.<%= field.name %>',
    before: undefined,
    filter: (one: <%= getEntityStrings().entityClass %>) => {
      throw new Error('not implemented');
    },
    loader: async (array: <%= getEntityStrings().entityClass %>[]) => {
      throw new Error('not implemented');
    },
    setter: (array: <%= getEntityStrings().entityClass %>[], loaded: <%= getAssociationStrings(field).entityClass %>[]) => {
      throw new Error('not implemented');
    },
    after: undefined,
  };
<% }); -%>
<% if (fields.some(isComputedSyncField)) { -%>

  /** computed sync fields */
<% } -%>
<% fields.filter(isComputedSyncField).forEach((field) => { -%>

  public get<%= toTitleCase(field.name) %>(): <%= field.type %> {
    throw new Error('not implemented');
  }
<% }); -%>
<% if (fields.some(isComputedAsyncField)) { -%>

  /** computed async fields */
<% } -%>
<% fields.filter(isComputedAsyncField).forEach((field) => { -%>

  public async get<%= toTitleCase(field.name) %>(): Promise<<%= field.type %>> {
    throw new Error('not implemented');
  }
<% }); -%>
}
