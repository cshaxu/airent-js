<% getGlobalImports().forEach((globalImport) => { -%>
<%- globalImport %>
<% }); -%>
import { toArrayMap, toObjectMap, nonNull, unique } from '<%= config.airentPackage %>';
import { <%= getThisEntityStrings().baseClass %> } from './generated/<%= getThisEntityStrings().basePackage %>';
<% if (!schema.internal || schema.fields.some(isInternalType)) { -%>
import {
  <%_ if (!schema.internal) { -%>
  <%= getThisEntityStrings().fieldRequestClass %>,
  <%= getThisEntityStrings().responseClass %>,
  <%_ } -%>
  <%_ schema.types.filter(isInternalType).forEach((type) => { -%>
  <%= getTypeStrings(type).typeName %>,
  <%_ }); -%>
} from './generated/<%= getThisEntityStrings().typePackage %>';
<% } -%>
<% schema.types.filter(isEntityType).filter((type) => type.name !== schema.entityName).forEach((type) => { -%>
import { <%= getTypeStrings(type).entityClass %> } from './<%= getTypeStrings(type).entityPackage %>';
<% }); -%>
<% schema.types.filter(isExternalType).forEach((type) => { -%>
import { <%= getTypeStrings(type).externalClass %> } from '<%= getTypeStrings(type).externalPackage %>';
<% }); -%>

<% if (schema.deprecated) { -%>
/** @deprecated */
<% } -%>
export class <%= getThisEntityStrings().entityClass %> extends <%= getThisEntityStrings().baseClass %> {
<% if (schema.fields.some(isAssociationField)) { -%>
  protected initialize() {
    super.initialize();

    /** associations */
  <%_ schema.fields.filter(isAssociationField).forEach((field) => { -%>
    <%_ if (!isLoaderGeneratable(field)) { -%>

    this.<%= `${field.name}Params` %>.loader = async (array: <%= getThisEntityStrings().baseClass %>[]) => {
      <%_ getSourceFields(field).forEach((sourceField) => { -%>
      const <%= pluralize(sourceField.name) %> = unique((nonNull(array.map((one) => one.<%= getFieldGetterName(sourceField) %>))));
      <%_ }); -%>
      const loadedModels = <%- getTargetLoadedModels(field) %>;
      return <%= getFieldStrings(field).fieldClass %>.fromArray(loadedModels);
    };
    <%_ } -%>
    <%_ if (!isSetterGeneratable(field)) { -%>

    this.<%= `${field.name}Params` %>.setter = ((array: <%= getThisEntityStrings().entityClass %>[], loaded: <%= getFieldStrings(field).fieldClass %>[]) => {
      const map = <%- getTargetMap(field) %>;
      array.forEach((one) => (one.<%= field.name %> = <%- getSourceSetter(field) %>));
    }) as (array: <%= getThisEntityStrings().baseClass %>[], loaded: <%= getFieldStrings(field).fieldClass %>[]) => Promise<void>;
    <%_ } -%>
  <%_ }); -%>
  }
<% } -%>
<% if (schema.fields.some(isComputedSyncField)) { -%>

  /** computed sync fields */
<% } -%>
<% schema.fields.filter(isComputedSyncField).forEach((field) => { -%>

  <%_ if (field.deprecated) { -%>
  /** @deprecated */
  <%_ } -%>
  public <%= getFieldStrings(field).fieldGetterName %>: <%= getFieldStrings(field).fieldType %> {
    throw new Error('not implemented');
  }
<% }); -%>
<% if (schema.fields.some(isComputedAsyncField)) { -%>

  /** computed async fields */
<% } -%>
<% schema.fields.filter(isComputedAsyncField).forEach((field) => { -%>

  <%_ if (field.deprecated) { -%>
  /** @deprecated */
  <%_ } -%>
  public async <%= getFieldStrings(field).fieldGetterName %>: Promise<<%= getFieldStrings(field).fieldType %>> {
    throw new Error('not implemented');
  }
<% }); -%>
}
